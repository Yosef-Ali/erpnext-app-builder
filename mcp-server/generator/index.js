/**
 * Enhanced ERPNext App Structure Generator
 * Generates complete ERPNext applications from Claude Hooks analysis
 */

const { v4: uuidv4 } = require('uuid');
const path = require('path');
const fs = require('fs').promises;

// Import the modern context engineering components
const TemplateManager = require('../templates/TemplateManager');

class ERPNextAppGenerator {
  constructor() {
    this.templates = {};
    this.templateManager = new TemplateManager();
    this.loadTemplates();
  }

  async loadTemplates() {
    // Wait for template manager to initialize
    await this.templateManager.initializeTemplates();

    // Load template configurations using the modern approach
    this.templates = {
      standard_fields: await this.getStandardFields(),
      industry_patterns: await this.getIndustryPatterns(),
      workflow_templates: await this.getWorkflowTemplates(),
      template_manager: this.templateManager
    };
  }

  async generate(analysis, templates, options = {}) {
    console.log('ðŸš€ Starting ERPNext app generation with modern context engineering...');

    // Use template manager for intelligent template suggestions
    const templateSuggestions = this.templateManager.suggestTemplates(analysis);
    const selectedTemplates = templates || templateSuggestions.recommended;

    console.log(`ðŸ“Š Analysis: ${analysis.entities?.length || 0} entities, ${analysis.workflows?.length || 0} workflows`);
    console.log(`ðŸŽ¯ Template compatibility: ${Math.round(templateSuggestions.compatibility_score * 100)}%`);

    const structure = {
      metadata: {
        app_name: this.sanitizeAppName(options.app_name || analysis.project_name || 'custom_app'),
        app_title: options.app_title || analysis.project_title || 'Custom App',
        app_description: options.app_description || analysis.description || 'Generated by ERPNext App Builder',
        app_publisher: options.app_publisher || 'ERPNext App Builder',
        app_email: options.app_email || 'builder@example.com',
        app_license: options.app_license || 'MIT',
        app_version: '0.0.1',
        generation_id: uuidv4(),
        generated_at: new Date().toISOString(),
        claude_analysis: analysis,
        template_suggestions: templateSuggestions,
        context_engineering: {
          version: '2.0',
          approach: 'modern_claude_hooks',
          compatibility_score: templateSuggestions.compatibility_score
        }
      },
      manifest: await this.generateManifest(analysis),
      doctypes: await this.generateDocTypes(analysis, selectedTemplates),
      workflows: await this.generateWorkflows(analysis, selectedTemplates),
      reports: await this.generateReports(analysis),
      permissions: await this.generatePermissions(analysis),
      web_forms: await this.generateWebForms(analysis),
      customizations: await this.generateCustomizations(analysis),
      hooks: await this.generateHooks(analysis),
      fixtures: await this.generateFixtures(analysis),
      scripts: {
        client: await this.generateClientScripts(analysis),
        server: await this.generateServerScripts(analysis)
      },
      installation: await this.generateInstallationGuide(analysis),
      quality_score: await this.calculateQualityScore(analysis, selectedTemplates)
    };

    console.log(`âœ… Generated ${structure.doctypes.length} DocTypes`);
    console.log(`âœ… Generated ${structure.workflows.length} Workflows`);
    console.log(`âœ… Generated ${structure.reports.length} Reports`);
    console.log(`âœ… Quality Score: ${structure.quality_score}/100`);
    console.log(`ðŸŽ¨ Template System: ${selectedTemplates.length} templates applied`);

    return structure;
  }

  async generateManifest(analysis) {
    return {
      dependencies: this.getRequiredDependencies(analysis),
      modules: this.getRequiredModules(analysis),
      country: analysis.country || 'Global',
      language: analysis.language || 'en',
      min_frappe_version: '15.0.0',
      min_erpnext_version: '15.0.0'
    };
  }

  async generateDocTypes(analysis, templates) {
    const doctypes = [];

    // Generate from entities
    if (analysis.entities) {
      for (const entity of analysis.entities) {
        const doctype = await this.createDocTypeFromEntity(entity, analysis);
        if (doctype) {
          doctypes.push(doctype);
        }
      }
    }

    // Generate child tables if needed
    const childTables = await this.generateChildTables(analysis, doctypes);
    doctypes.push(...childTables);

    // Apply industry-specific enhancements
    await this.applyIndustryPatterns(doctypes, analysis.industry);

    return doctypes;
  }

  async createDocTypeFromEntity(entity, analysis) {
    const doctype = {
      doctype: 'DocType',
      name: entity.name || entity.doctype,
      module: this.getModuleName(entity, analysis),
      custom: 1,
      autoname: this.generateNamingSeries(entity),
      is_submittable: this.shouldBeSubmittable(entity),
      track_changes: 1,
      track_seen: 1,
      description: entity.description || `${entity.name} management`,
      fields: [],
      permissions: [],
      links: [],
      actions: []
    };

    // Add fields based on entity type and requirements
    doctype.fields = await this.generateFieldsForEntity(entity, analysis);

    // Add permissions
    doctype.permissions = await this.generatePermissionsForEntity(entity, analysis);

    // Add document links
    doctype.links = await this.generateLinksForEntity(entity, analysis);

    return doctype;
  }

  async generateFieldsForEntity(entity, analysis) {
    const fields = [];
    let idx = 1;

    // Section Break - Basic Information
    fields.push({
      fieldname: 'basic_info_section',
      fieldtype: 'Section Break',
      label: 'Basic Information',
      idx: idx++
    });

    // Title field (always first)
    const titleField = this.getTitleField(entity);
    titleField.idx = idx++;
    fields.push(titleField);

    // Entity-specific fields
    const entityFields = await this.getEntitySpecificFields(entity, analysis);
    entityFields.forEach(field => {
      field.idx = idx++;
      fields.push(field);
    });

    // Add status field if submittable
    if (this.shouldBeSubmittable(entity)) {
      fields.push({
        fieldname: 'status',
        fieldtype: 'Select',
        label: 'Status',
        options: 'Draft\nPending\nApproved\nCancelled',
        default: 'Draft',
        idx: idx++
      });
    }

    // Add relationships
    const relationshipFields = await this.getRelationshipFields(entity, analysis);
    if (relationshipFields.length > 0) {
      fields.push({
        fieldname: 'relationships_section',
        fieldtype: 'Section Break',
        label: 'Relationships',
        idx: idx++
      });

      relationshipFields.forEach(field => {
        field.idx = idx++;
        fields.push(field);
      });
    }

    // Add audit fields
    const auditFields = this.getAuditFields();
    auditFields.forEach(field => {
      field.idx = idx++;
      fields.push(field);
    });

    return fields;
  }

  getTitleField(entity) {
    const entityName = (entity.name || entity.doctype || 'Item').toLowerCase();

    return {
      fieldname: entityName.replace(/\s+/g, '_') + '_name',
      fieldtype: 'Data',
      label: `${entity.name || entity.doctype} Name`,
      reqd: 1,
      bold: 1,
      in_list_view: 1,
      in_standard_filter: 1,
      description: `Enter the name of the ${entity.name || entity.doctype}`
    };
  }

  async getEntitySpecificFields(entity, analysis) {
    const fields = [];
    const entityType = (entity.name || entity.doctype || '').toLowerCase();

    // Customer/Supplier specific fields
    if (entityType.includes('customer') || entityType.includes('supplier') || entityType.includes('vendor')) {
      fields.push(
        {
          fieldname: 'email',
          fieldtype: 'Data',
          label: 'Email',
          options: 'Email',
          in_list_view: 1
        },
        {
          fieldname: 'phone',
          fieldtype: 'Data',
          label: 'Phone',
          options: 'Phone'
        },
        {
          fieldname: 'address',
          fieldtype: 'Small Text',
          label: 'Address'
        }
      );
    }

    // Product/Item specific fields
    if (entityType.includes('product') || entityType.includes('item')) {
      fields.push(
        {
          fieldname: 'item_code',
          fieldtype: 'Data',
          label: 'Item Code',
          unique: 1
        },
        {
          fieldname: 'price',
          fieldtype: 'Currency',
          label: 'Price'
        },
        {
          fieldname: 'stock_qty',
          fieldtype: 'Float',
          label: 'Stock Quantity',
          precision: 2
        }
      );
    }

    // Order specific fields
    if (entityType.includes('order')) {
      fields.push(
        {
          fieldname: 'order_date',
          fieldtype: 'Date',
          label: 'Order Date',
          default: 'Today'
        },
        {
          fieldname: 'total_amount',
          fieldtype: 'Currency',
          label: 'Total Amount',
          read_only: 1
        }
      );
    }

    // Invoice specific fields
    if (entityType.includes('invoice')) {
      fields.push(
        {
          fieldname: 'invoice_date',
          fieldtype: 'Date',
          label: 'Invoice Date',
          default: 'Today'
        },
        {
          fieldname: 'due_date',
          fieldtype: 'Date',
          label: 'Due Date'
        },
        {
          fieldname: 'payment_status',
          fieldtype: 'Select',
          label: 'Payment Status',
          options: 'Unpaid\nPartially Paid\nPaid\nOverdue'
        }
      );
    }

    // Project specific fields
    if (entityType.includes('project')) {
      fields.push(
        {
          fieldname: 'start_date',
          fieldtype: 'Date',
          label: 'Start Date'
        },
        {
          fieldname: 'end_date',
          fieldtype: 'Date',
          label: 'End Date'
        },
        {
          fieldname: 'progress',
          fieldtype: 'Percent',
          label: 'Progress'
        }
      );
    }

    return fields;
  }

  async getRelationshipFields(entity, analysis) {
    const fields = [];

    // Generate link fields based on analysis relationships
    if (analysis.relationships) {
      analysis.relationships.forEach(rel => {
        if (rel.from_entity === entity.type || rel.to_entity === entity.type) {
          const otherEntity = rel.from_entity === entity.type ? rel.to_entity : rel.from_entity;

          fields.push({
            fieldname: otherEntity.toLowerCase() + '_link',
            fieldtype: 'Link',
            label: otherEntity.charAt(0).toUpperCase() + otherEntity.slice(1),
            options: this.getDocTypeName(otherEntity)
          });
        }
      });
    }

    return fields;
  }

  getAuditFields() {
    return [
      {
        fieldname: 'audit_section',
        fieldtype: 'Section Break',
        label: 'Audit Information',
        collapsible: 1
      },
      {
        fieldname: 'notes',
        fieldtype: 'Text Editor',
        label: 'Notes'
      }
    ];
  }

  async generateWorkflows(analysis, selectedTemplates) {
    const workflows = [];

    // Generate workflows from analysis
    if (analysis.workflows) {
      for (const workflow of analysis.workflows) {
        const wf = await this.createWorkflow(workflow, analysis);
        if (wf) {
          workflows.push(wf);
        }
      }
    }

    // Add template-based workflows
    if (selectedTemplates && selectedTemplates.length > 0) {
      for (const template of selectedTemplates) {
        if (template.workflows) {
          for (const templateWorkflow of template.workflows) {
            const wf = await this.createWorkflowFromTemplate(templateWorkflow, analysis);
            if (wf) {
              workflows.push(wf);
            }
          }
        }
      }
    }

    return workflows;
  }

  async createWorkflow(workflow, analysis) {
    const states = this.getWorkflowStates(workflow);
    const transitions = this.getWorkflowTransitions(states, workflow);

    return {
      doctype: 'Workflow',
      name: workflow.name || 'Custom Workflow',
      document_type: workflow.document_type || this.getDefaultDocType(analysis),
      is_active: 1,
      send_email_alert: 1,
      states: states,
      transitions: transitions
    };
  }

  async createWorkflowFromTemplate(templateWorkflow, analysis) {
    return {
      doctype: 'Workflow',
      name: templateWorkflow.name || 'Template Workflow',
      document_type: templateWorkflow.document_type || this.getDefaultDocType(analysis),
      is_active: templateWorkflow.is_active !== undefined ? templateWorkflow.is_active : 1,
      send_email_alert: 1,
      states: templateWorkflow.states || this.getDefaultStates(),
      transitions: templateWorkflow.transitions || this.getDefaultTransitions(templateWorkflow.states || this.getDefaultStates())
    };
  }

  getWorkflowStates(workflow) {
    const defaultStates = [
      { state: 'Draft', style: 'Warning', doc_status: 0 },
      { state: 'Pending Review', style: 'Info', doc_status: 0 },
      { state: 'Approved', style: 'Success', doc_status: 1 },
      { state: 'Rejected', style: 'Danger', doc_status: 2 }
    ];

    return workflow.states || defaultStates;
  }

  getWorkflowTransitions(states, workflow) {
    const transitions = [];

    // Generate basic transitions between states
    for (let i = 0; i < states.length - 1; i++) {
      transitions.push({
        state: states[i].state,
        action: `Approve to ${states[i + 1].state}`,
        next_state: states[i + 1].state,
        allowed: 'System Manager'
      });
    }

    return transitions;
  }

  getDefaultStates() {
    return [
      { state: 'Draft', style: 'Warning', doc_status: 0 },
      { state: 'Pending', style: 'Info', doc_status: 0 },
      { state: 'Approved', style: 'Success', doc_status: 1 },
      { state: 'Rejected', style: 'Danger', doc_status: 2 }
    ];
  }

  getDefaultTransitions(states) {
    const transitions = [];
    for (let i = 0; i < states.length - 1; i++) {
      transitions.push({
        state: states[i].state,
        action: `Move to ${states[i + 1].state}`,
        next_state: states[i + 1].state,
        allowed: 'System Manager'
      });
    }
    return transitions;
  }

  // Helper methods continue...
  sanitizeAppName(name) {
    return name.toLowerCase().replace(/[^a-z0-9_]/g, '_').replace(/_{2,}/g, '_');
  }

  getModuleName(entity, analysis) {
    if (analysis.industry) {
      return analysis.industry.charAt(0).toUpperCase() + analysis.industry.slice(1);
    }
    return 'Custom';
  }

  generateNamingSeries(entity) {
    const prefix = (entity.name || entity.doctype || 'ITEM').substring(0, 3).toUpperCase();
    return `format:${prefix}-{####}`;
  }

  shouldBeSubmittable(entity) {
    const submittableTypes = ['order', 'invoice', 'quotation', 'contract', 'approval'];
    const entityType = (entity.name || entity.doctype || '').toLowerCase();
    return submittableTypes.some(type => entityType.includes(type));
  }

  getDocTypeName(entity) {
    return entity.charAt(0).toUpperCase() + entity.slice(1).replace(/_/g, ' ');
  }

  // More methods would continue here...
  async generateReports(analysis) {
    return []; // Placeholder for report generation
  }

  async generatePermissions(analysis) {
    return []; // Placeholder for permission generation
  }

  async generateWebForms(analysis) {
    return []; // Placeholder for web form generation
  }

  async generateCustomizations(analysis) {
    return []; // Placeholder for customization generation
  }

  async generateHooks(analysis) {
    return []; // Placeholder for hooks generation
  }

  async generateFixtures(analysis) {
    return []; // Placeholder for fixtures generation
  }

  async generateClientScripts(analysis) {
    return []; // Placeholder for client scripts
  }

  async generateServerScripts(analysis) {
    return []; // Placeholder for server scripts
  }

  async generateInstallationGuide(analysis) {
    return {
      steps: [
        'Install Frappe/ERPNext',
        'Create new site',
        'Install generated app',
        'Run setup wizard'
      ]
    };
  }

  async calculateQualityScore(analysis, selectedTemplates) {
    let score = 0;

    // Basic scoring logic
    if (analysis.entities && analysis.entities.length > 0) score += 25;
    if (analysis.workflows && analysis.workflows.length > 0) score += 20;
    if (analysis.relationships && analysis.relationships.length > 0) score += 15;
    if (analysis.complexity_assessment) score += 10;
    if (analysis.industry && analysis.industry !== 'general') score += 10;

    // Template integration scoring
    if (selectedTemplates && selectedTemplates.length > 0) {
      score += 15; // Bonus for using templates

      // Template quality bonus
      const avgTemplateScore = selectedTemplates.reduce((acc, template) =>
        acc + (template.compatibility_score || 0.5), 0) / selectedTemplates.length;
      score += Math.round(avgTemplateScore * 5);
    }

    return Math.min(score, 100);
  }

  // Placeholder methods for loading templates
  async getStandardFields() {
    return {};
  }

  async getIndustryPatterns() {
    return {};
  }

  async getWorkflowTemplates() {
    return {};
  }

  getRequiredDependencies(analysis) {
    return ['frappe', 'erpnext'];
  }

  getRequiredModules(analysis) {
    return ['Custom'];
  }

  async generateChildTables(analysis, doctypes) {
    return [];
  }

  async applyIndustryPatterns(doctypes, industry) {
    // Industry-specific enhancements
    return doctypes;
  }

  async generatePermissionsForEntity(entity, analysis) {
    return [
      {
        role: 'System Manager',
        read: 1,
        write: 1,
        create: 1,
        delete: 1
      },
      {
        role: 'All',
        read: 1
      }
    ];
  }

  async generateLinksForEntity(entity, analysis) {
    return [];
  }

  getDefaultDocType(analysis) {
    if (analysis.entities && analysis.entities.length > 0) {
      return analysis.entities[0].name || 'Custom DocType';
    }
    return 'Custom DocType';
  }
}

// Export the generator
const generateAppStructure = async (analysis, templates, options = {}) => {
  const generator = new ERPNextAppGenerator();
  await generator.loadTemplates(); // Ensure templates are loaded
  return await generator.generate(analysis, templates, options);
};

module.exports = {
  generate: generateAppStructure,
  ERPNextAppGenerator
};
